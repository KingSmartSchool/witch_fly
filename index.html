<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>魔法女巫飛行記</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
            overflow: hidden;
            height: 100vh;
            background: #000;
        }
        
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        .parallax-layer {
            position: absolute;
            width: 300%;
            height: 100%;
            background-repeat: repeat-x;
        }
        
        #layer-1 {
            background: linear-gradient(to bottom, #020111 0%, #191938 80%, #20205a 100%);
            z-index: 1;
        }
        
        #layer-2 {
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="100" viewBox="0 0 200 100"><circle cx="20" cy="30" r="1" fill="white" opacity="0.8"/><circle cx="70" cy="15" r="1" fill="white" opacity="0.6"/><circle cx="120" cy="40" r="1" fill="white" opacity="0.9"/><circle cx="180" cy="25" r="1" fill="white" opacity="0.7"/></svg>');
            z-index: 2;
            animation: parallax 300s linear infinite;
        }
        
        #layer-3 {
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="400" height="200" viewBox="0 0 400 200"><path d="M0,150 Q100,100 200,150 T400,150" stroke="%23111" fill="none" stroke-width="2"/></svg>');
            z-index: 3;
            animation: parallax 150s linear infinite;
            opacity: 0.3;
        }
        
        @keyframes parallax {
            0% { transform: translateX(0); }
            100% { transform: translateX(-66.6%); }
        }
        
        #witch {
            position: absolute;
            width: 100px;
            height: 80px;
            left: 15%;
            z-index: 10;
            transform-origin: center 70%;
            transition: transform 0.2s ease-out;
            filter: drop-shadow(0 0 5px rgba(179, 102, 255, 0.7));
        }
        
        .obstacle {
            position: absolute;
            z-index: 5;
        }
        
        .cloud {
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 120 60"><path d="M20,30 Q30,10 50,20 Q70,5 90,20 Q110,15 110,30 Q130,40 100,50 Q110,60 80,55 Q60,70 40,50 Q10,60 10,40 Q5,30 20,30" fill="white"/></svg>');
            background-size: contain;
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.5));
            animation: float 3s ease-in-out infinite alternate;
        }
        
        .bird {
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 30"><path d="M5,15 Q15,5 25,15 Q35,25 45,15 L35,20 Q25,15 15,20 Z" fill="%23FF9800"/></svg>');
            background-size: contain;
            animation: fly 1s steps(4) infinite;
        }
        
        .lightning {
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 30 80"><path d="M15,0 L5,40 L15,30 L25,80 L15,50 L5,60 Z" fill="yellow"/></svg>');
            background-size: contain;
            filter: drop-shadow(0 0 10px yellow);
            animation: flash 0.2s infinite alternate;
        }
        
        @keyframes float {
            0% { transform: translateY(0); }
            100% { transform: translateY(-20px); }
        }
        
        @keyframes fly {
            0% { transform: translateX(0); }
            100% { transform: translateX(-10px); }
        }
        
        @keyframes flash {
            0% { opacity: 0.3; }
            100% { opacity: 1; }
        }
        
        .particle {
            position: absolute;
            background: white;
            border-radius: 50%;
            pointer-events: none;
            z-index: 4;
        }
        
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none;
        }
        
        #score-display {
            position: absolute;
            top: 30px;
            left: 30px;
            color: white;
            font-size: 24px;
            text-shadow: 0 0 10px #b366ff, 0 0 20px #b366ff;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 20px;
            border: 2px solid #b366ff;
        }
        
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.8);
            color: white;
            z-index: 30;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        
        #game-over.show {
            opacity: 1;
            pointer-events: all;
        }
        
        #game-over h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ff66b2;
            text-shadow: 0 0 10px #ff66b2;
        }
        
        #final-score {
            font-size: 32px;
            margin-bottom: 30px;
        }
        
        #restart-btn {
            padding: 15px 30px;
            font-size: 20px;
            background: linear-gradient(to right, #b366ff, #ff66b2);
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            box-shadow: 0 0 20px rgba(179, 102, 255, 0.5);
        }
        
        #restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(179, 102, 255, 0.8);
        }
        
        #mobile-controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: none;
            justify-content: center;
            z-index: 25;
        }
        
        #jump-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(179, 102, 255, 0.3);
            border: 3px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 16px;
            backdrop-filter: blur(5px);
        }
        
        @media (max-width: 768px) {
            #mobile-controls {
                display: flex;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="layer-1" class="parallax-layer"></div>
        <div id="layer-2" class="parallax-layer"></div>
        <div id="layer-3" class="parallax-layer"></div>
        
        <div id="witch">
            <svg viewBox="0 0 100 100">
                <path d="M70,50 L95,35 L100,40 L85,55 Z" fill="#5D4037"/>
                <path d="M30,50 Q50,30 70,50 L60,70 Q50,80 40,70 Z" fill="#7E57C2"/>
                <path d="M35,30 L65,30 L50,10 Z" fill="#4527A0"/>
                <circle cx="40" cy="45" r="3" fill="#FFD600"/>
                <circle cx="50" cy="45" r="3" fill="#FFD600"/>
                <path d="M70,50 L80,45 L75,55 Z" fill="#FFD600" opacity="0.8"/>
            </svg>
        </div>
        
        <div id="ui-container">
            <div id="score-display">0</div>
            <div id="mobile-controls">
                <button id="jump-btn">跳躍</button>
            </div>
        </div>
        
        <div id="game-over">
            <h1>遊戲結束!</h1>
            <div id="final-score">得分: 0</div>
            <button id="restart-btn">再玩一次</button>
        </div>
    </div>

    <script>
        class WitchGame {
            constructor() {
                this.witch = document.getElementById('witch');
                this.gameContainer = document.getElementById('game-container');
                this.scoreDisplay = document.getElementById('score-display');
                this.gameOverScreen = document.getElementById('game-over');
                this.finalScoreDisplay = document.getElementById('final-score');
                this.restartBtn = document.getElementById('restart-btn');
                this.jumpBtn = document.getElementById('jump-btn');
                
                this.witchY = 50;
                this.velocity = 0;
                this.gravity = 0.4;
                this.gameSpeed = 5;
                this.score = 0;
                this.highScore = localStorage.getItem('highScore') || 0;
                this.gameRunning = false;
                this.obstacles = [];
                this.particles = [];
                this.animationId = null;
                this.obstacleInterval = null;
                
                this.initEventListeners();
                this.startGame();
            }
            
            initEventListeners() {
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        this.jump();
                        e.preventDefault();
                    }
                });
                
                document.addEventListener('touchstart', (e) => {
                    this.jump();
                    e.preventDefault();
                });
                
                this.jumpBtn.addEventListener('click', () => this.jump());
                this.restartBtn.addEventListener('click', () => this.startGame());
            }
            
            startGame() {
                this.resetGame();
                this.gameLoop();
                this.obstacleInterval = setInterval(() => this.spawnObstacle(), 1500);
            }
            
            resetGame() {
                this.clearObstacles();
                this.clearParticles();
                
                this.witchY = 50;
                this.velocity = 0;
                this.gameSpeed = 5;
                this.score = 0;
                this.gameRunning = true;
                
                this.scoreDisplay.textContent = '0';
                this.gameOverScreen.classList.remove('show');
                
                this.witch.style.top = `${this.witchY}%`;
                this.witch.style.transform = 'rotate(0deg)';
            }
            
            gameLoop() {
                if (!this.gameRunning) return;
                
                this.updateWitch();
                this.updateObstacles();
                this.updateParticles();
                this.checkCollisions();
                
                this.animationId = requestAnimationFrame(() => this.gameLoop());
            }
            
            updateWitch() {
                this.velocity += this.gravity;
                this.witchY += this.velocity;
                this.witchY = Math.max(0, Math.min(this.witchY, 90));
                this.witch.style.top = `${this.witchY}%`;
                
                let rotation = this.velocity * 2;
                rotation = Math.max(-15, Math.min(rotation, 15));
                this.witch.style.transform = `rotate(${rotation}deg)`;
                
                if (this.velocity < 0 && Math.random() < 0.3) {
                    this.createParticle(
                        parseInt(this.witch.style.left) + 70,
                        parseInt(this.witch.style.top) + 40,
                        '#FFD600',
                        2,
                        1
                    );
                }
            }
            
            jump() {
                if (!this.gameRunning) return;
                
                this.velocity = -10;
                
                for (let i = 0; i < 10; i++) {
                    this.createParticle(
                        parseInt(this.witch.style.left) + 70,
                        parseInt(this.witch.style.top) + 40,
                        '#B366FF',
                        Math.random() * 3 + 1,
                        0.5
                    );
                }
            }
            
            spawnObstacle() {
                if (!this.gameRunning) return;
                
                const types = [
                    { type: 'cloud', width: 120, height: 60 },
                    { type: 'bird', width: 50, height: 30 },
                    { type: 'lightning', width: 30, height: 80 }
                ];
                const obstacleType = types[Math.floor(Math.random() * types.length)];
                
                const obstacle = document.createElement('div');
                obstacle.className = `obstacle ${obstacleType.type}`;
                
                const left = window.innerWidth;
                const top = Math.random() * 70 + 5;
                
                obstacle.style.left = `${left}px`;
                obstacle.style.top = `${top}%`;
                obstacle.style.width = `${obstacleType.width}px`;
                obstacle.style.height = `${obstacleType.height}px`;
                
                this.gameContainer.appendChild(obstacle);
                
                this.obstacles.push({
                    element: obstacle,
                    left,
                    top,
                    width: obstacleType.width,
                    height: obstacleType.height,
                    type: obstacleType.type
                });
            }
            
            updateObstacles() {
                for (let i = this.obstacles.length - 1; i >= 0; i--) {
                    const obs = this.obstacles[i];
                    
                    obs.left -= this.gameSpeed;
                    obs.element.style.left = `${obs.left}px`;
                    
                    if (obs.left + obs.width < 0) {
                        obs.element.remove();
                        this.obstacles.splice(i, 1);
                        this.score++;
                        this.scoreDisplay.textContent = this.score;
                        
                        if (this.score % 10 === 0) {
                            this.gameSpeed += 0.5;
                        }
                    }
                }
            }
            
            checkCollisions() {
                const witchRect = {
                    left: 15 * window.innerWidth / 100,
                    top: this.witchY * window.innerHeight / 100,
                    right: (15 * window.innerWidth / 100) + 100,
                    bottom: (this.witchY * window.innerHeight / 100) + 80
                };
                
                for (let i = 0; i < this.obstacles.length; i++) {
                    const obs = this.obstacles[i];
                    const obsRect = {
                        left: obs.left,
                        top: obs.top * window.innerHeight / 100,
                        right: obs.left + obs.width,
                        bottom: (obs.top * window.innerHeight / 100) + obs.height
                    };
                    
                    if (
                        witchRect.left < obsRect.right &&
                        witchRect.right > obsRect.left &&
                        witchRect.top < obsRect.bottom &&
                        witchRect.bottom > obsRect.top
                    ) {
                        if (obs.type === 'cloud') {
                            this.gameSpeed = Math.max(3, this.gameSpeed - 1);
                            this.createParticles(obsRect.left + obs.width/2, obsRect.top + obs.height/2, 10, '#FFFFFF');
                            obs.element.remove();
                            this.obstacles.splice(i, 1);
                            i--;
                        } else {
                            this.gameOver();
                            return;
                        }
                    }
                }
            }
            
            createParticle(x, y, color, size, lifetime) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                particle.style.backgroundColor = color;
                particle.style.opacity = '0.8';
                
                this.gameContainer.appendChild(particle);
                
                this.particles.push({
                    element: particle,
                    x,
                    y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5,
                    lifetime,
                    age: 0
                });
            }
            
            createParticles(x, y, count, color) {
                for (let i = 0; i < count; i++) {
                    this.createParticle(
                        x,
                        y,
                        color,
                        Math.random() * 5 + 2,
                        Math.random() * 0.5 + 0.3
                    );
                }
            }
            
            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    
                    p.x += p.vx;
                    p.y += p.vy;
                    p.age += 0.016;
                    
                    p.element.style.left = `${p.x}px`;
                    p.element.style.top = `${p.y}px`;
                    p.element.style.opacity = 0.8 * (1 - p.age / p.lifetime);
                    
                    if (p.age >= p.lifetime) {
                        p.element.remove();
                        this.particles.splice(i, 1);
                    }
                }
            }
            
            gameOver() {
                this.gameRunning = false;
                clearInterval(this.obstacleInterval);
                cancelAnimationFrame(this.animationId);
                
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('highScore', this.highScore);
                }
                
                this.finalScoreDisplay.innerHTML = `
                    得分: ${this.score}<br>
                    最高分: ${this.highScore}
                `;
                this.gameOverScreen.classList.add('show');
                
                let fallInterval = setInterval(() => {
                    this.witchY += 3;
                    this.witch.style.top = `${this.witchY}%`;
                    this.witch.style.transform = 'rotate(90deg)';
                    
                    if (this.witchY > 150) {
                        clearInterval(fallInterval);
                    }
                }, 50);
                
                const witchRect = this.witch.getBoundingClientRect();
                this.createParticles(
                    witchRect.left + witchRect.width/2,
                    witchRect.top + witchRect.height/2,
                    30,
                    '#FF6600'
                );
            }
            
            clearObstacles() {
                this.obstacles.forEach(obs => obs.element.remove());
                this.obstacles = [];
            }
            
            clearParticles() {
                this.particles.forEach(p => p.element.remove());
                this.particles = [];
            }
        }
        
        // 確保DOM完全載入後才初始化遊戲
        document.addEventListener('DOMContentLoaded', () => {
            new WitchGame();
        });
    </script>
</body>
</html>
